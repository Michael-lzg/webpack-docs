# webpack 异步加载原理

webpack ensure 有人称他为异步加载，也有人称为代码切割，他其实就是将 js 模块给独立导出一个.js 文件，然后使用这个模块的时候，再创建一个 script 对象，加入到 document.head 对象中就可，浏览器会自动帮我们发起请求，去请求这个 js 文件，然后写个回调函数，让请求到的 js 文件做一些业务操作。

### 举个例子

需求：main.js 依赖两个个 js 文件：A.js 是点击 aBtn 按钮后，才执行的逻辑，B.js 是点击 bBtn 按钮后，才执行的逻辑。

webpack.config.js，我们先来写一下 webpack 打包的配置的代码

```js
const path = require('path') // 路径处理模块
const HtmlWebpackPlugin = require('html-webpack-plugin')
const { CleanWebpackPlugin } = require('clean-webpack-plugin') // 引入CleanWebpackPlugin插件

module.exports = {
  entry: {
    index: path.join(__dirname, '/src/main.js'),
  },
  output: {
    path: path.join(__dirname, '/dist'),
    filename: 'index.js',
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.join(__dirname, '/index.html'),
    }),
    new CleanWebpackPlugin(), // 所要清理的文件夹名称
  ],
}
```

index.html 代码如下

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>webpack</title>
  </head>
  <body>
    <div id="app">
      <button id="aBtn">按钮A</button>
      <button id="bBtn">按钮B</button>
    </div>
  </body>
</html>
```

入口文件 main.js 如下

```js
import A from './A'
import B from './B'

document.getElementById('aBtn').onclick = function () {
  alert(A)
}

document.getElementById('bBtn').onclick = function () {
  alert(B)
}
```

A.js 和 B.js 的代码分别如下

```js
// A.js
const A = 'hello A'
module.exports = A

// B.js
const B = 'hello B'
module.exports = B
```

此时，我们对项目进行 npm run build， 打包出来的只有两个文件

- index.html
- index.js

由此可见，此时 webpack 把 main.js 依赖的两个文件都同时打包到同一个 js 文件，并在 index.html 中引入。但是 A.js 和 B.js 都是点击相应按钮才会执行的逻辑，如果用户并没有点击相应按钮，而且这两个文件又是比较大的话，这样是不是就导致首页默认加载的 js 文件太大，从而导致首页渲染较慢呢？那么有能否实现当用户点击按钮的时候再加载相应的依赖文件呢？

webpack.ensure 就解决了这个问题。

### 异步加载

下面我们将 main.js 改成异步加载的方式

```js
document.getElementById('aBtn').onclick = function () {
  //异步加载A
  require.ensure([], function () {
    //当A.js需要依赖于B.js的时候，需要在[]中加入
    let A = require('./A.js')
    alert(A)
  })
}

document.getElementById('bBtn').onclick = function () {
  //异步加载b
  require.ensure([], function () {
    let B = require('./B.js')
    alert(B)
  })
}
```

此时，我们在进行一下打包，发现多了 1.index.js 和 2.index.js 两个文件。而我们打开页面时只引入了 index.js 一个文件，当点击按钮 A 的时候才引入 1.index.js 文件，点击按钮 B 的时候才引入 2.index.js 文件。这样就满足了我们的需求，按需加载。

我们打开 1.index.js 文件，发现它的代码如下

```js
;(window.webpackJsonp = window.webpackJsonp || []).push([
  [1],
  [
    ,
    function (o, n) {
      o.exports = 'hello A'
    },
  ],
])
```

require.ensure 这个函数是一个代码分离的分割线，表示回调里面的 require 是我们想要进行分割出去的，即 require('./A.js')，把 A.js 分割出去，形成一个 webpack 打包的单独 js 文件。它的语法如下

```js
require.ensure(dependencies: String[], callback: function(require), chunkName: String)
```

### import()

这个的进口不同于模块引入时的导入，可以理解为一个动态加载的模块的函数（函数等），传入其中的参数就是相应的模块。例如对于原有的模块引入从 '反应' 导入写为进口（'反应'）但是需要注意的是，进口（）会返回一个无极对象因此，可以通过如下方式使用：

```js
document.getElementById('aBtn').onclick = function () {
  //异步加载A
  import('./A').then((data) => {
    alert(data.A)
  })
}

document.getElementById('bBtn').onclick = function () {
  //异步加载b
  import('./B').then((data) => {
    alert(data.B)
  })
}
```

此时打包出来的文件和 webpack.ensure 方法是一样的
