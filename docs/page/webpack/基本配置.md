### Webpack 的四大核心：

- entry：js 入口源文件
- output：生成文件
- loader：进行文件处理
- plugins：插件，比 loader 更强大，能使用更多 webpack 的 api

## Entry

webpack 应该使用哪个模块做为入口文件，来作为构建其内部依赖图的开始。进去入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的，每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。

单⼊⼝：entry 是⼀个字符串

```js
module.exports = {
  entry: './src/index.js',
}
```

多⼊⼝：entry 是⼀个对象

```js
module.exports = {
  entry: {
    index: './src/index.js',
    manager: './src/manager.js',
  },
}
```

## Output

告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，这些都可以在 webpack 的配置文件中指定。

单⼊⼝配置

```js
module.exports = {
    entry: './src/index.js',
    output: {
        filename: 'bundle.js’,
        path: __dirname + '/dist'
    }
};
```

多⼊⼝配置

```js
module.exports = {
  entry: {
    app: './src/app.js',
    search: './src/search.js',
  },
  output: {
    filename: '[name].js',
    path: __dirname + '/dist',
  },
}
```

此外，还可以生成带 hash 的 fileName。

```js
module.exports = {
  entry: {
    app: './src/app.js',
    search: './src/search.js',
  },
  output: {
    path: path.join(__dirname, '/dist'), //打包后的文件存放的地方
    filename: 'js/[name].[chunkhash:8].js',
    chunkFilename: 'js/[name].[chunkhash:8].js',
  },
}
```

## Loader

`loader` 让 `webpack` 能够去处理那些非 `javaScript` 文件（`webpack` 自身只理解 `javaScript`）。`loader` 可以将所有类型的文件转换为 `webpack` 能够处理的有效模块，然后你就可以利用 `webpack` 的打包能力，对它们进行处理。

### loader 的特点

- 一个 Loader 的职责是单一的，只需要完成一种转换
- 一个 Loader 其实就是一个 Node.js 模块，这个模块需要导出一个函数
- loader 总是从右到左地被调用。

### loader 的配置

在配置文件中加入 module 这个配置项，它是一个对象，在这个对象里面配置相应的处理模块的规则。

在 module 的选项里 有一个 rules 数组，rules 就是配置模块的读取和解析规则，通常就是用来配置 loader。数组里面的每一项都描述了如何处理对应的文件，配置一项 rules 时大致可以通过一项方式来完成：

```js
// 方法一
{
  test: /\.jsx?$/, //匹配规则
  use: 'babel-loader'
  // use: ['style-loader', 'css-loader'] 多个loader
}

// 方法二
{
  test: /\.jsx?$/,
  loader: 'babel-loader',
  options: {
      //...
  }
}

```

### 常用的 loader

#### 处理样式

- `css-loader`: 加载.css 文件，
- `style-loader`:使用 style 标签将 `css-loader` 内部样式注入到我们的 html 页面
- `less-loader, sass-loader`: 解析 css 预处理器
- `postcss-loader` css 增加前缀

```js
rules: [
  {
    test: /\.css$/, // 正则匹配以.css结尾的文件
    use: ['style-loader', 'css-loader', 'postcss-loader'],
  },
  {
    test: /\.less$/,
    use: ['style-loader', 'css-loader', 'postcss-loader', 'less-loader'],
  },
]
```

- `style-loader` 放在 `css-loader` 后面是因为 webpack 打包机制是按照数组从后往前的顺序将资源交个 loader 处理。
- `postcss-loade`r 要和`autoprefixer`一起使用。在项目根目录下新建 postcss.config.js 文件:

```js
module.exports = {
  plugins: [
    require('autoprefixer'), // 引用autoprefixer模块
  ],
}
```

#### 处理 js

- 让你能使用最新的 js 代码（ES6，ES7...）
- 让你能使用基于 js 进行了拓展的语言，比如 React 的 JSX；

```js
rules: [
  {
    test: /\.js$/,
    exclude: '/node_modules/',
    use: {
      loader: 'babel-loader',
      options: {
        cacheDirectory: true,
        presets: [['env', { modules: false }]],
      },
    },
  },
]
```

- `exclude`，排除了目录 `node_modules`，可不编译 `node_modules` 目录中的模块，提高打包速度；
- `babel-loader`，转译 ES6+;
- `@babel/core`，babel 编译器核心模块；
- `@babel/preset-env`，预置器，根据用户配置的目标环境自动添加需要的插件和补丁来编译 ES6+；
- `cacheDirectory`，缓存机制，这里设为 true，在重复打包未改变的模块时防止二次编译，提高打包速度，指向 `node_modules/.cache/babel-loader`；
- `presets` 的 modules 设置为 false，意思是禁止让 `@babel/preset-env` 将模块语句转换，让 `ES6 Module` 语法给 webpack 处理，若是为 true，会将 `ES6 Module` 模块转化为 `CommonJS` 形式，这将会导致 `tree-shaking` 特性失效；

此外，babel-loader 还有如下优化写法：在项目根目录下新建.babelrc 文件

```js
{
  "presets": ["env", "react"]
}

```

#### 处理文件

处理图片资源时，我们常用的两种 loader 是`file-loader`或者`url-loader`，两者的主要差异在于。`url-loader`可以设置图片大小限制，当图片超过限制时，其表现行为等同于`file-loader`，而当图片不超过限制时，则会将图片以`base64`的形式打包进 css 文件，以减少请求次数

```js
{
  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
  loader: 'url-loader',
  options: {
    limit: 10000,
    name: utils.assetsPath('img/[name].[hash:7].[ext]')
  }
}
```

#### 压缩图片

在项目中有些图片太大影响加载，我们用 image-webpack-loader 进行压缩。

```js
rules: [
  {
    test: /\.(png|jpg|svg|gif)$/,
    use: [
      {
        loader: 'url-loader',
        options: {
          esModule: false,
          limit: 1000, // 限制只有小于1kb的图片才转为base64，例子图片为1.47kb,所以不会被转化
          outputPath: 'images', // 设置打包后图片存放的文件夹名称
          name: '[name][hash:8].[ext]',
        },
      },
      {
        loader: 'image-webpack-loader',
        options: {
          // 压缩 jpeg 的配置
          mozjpeg: {
            progressive: true,
            quality: 65,
          },
          // 使用 imagemin**-optipng 压缩 png，enable: false 为关闭
          optipng: {
            enabled: false,
          },
          // // 使用 imagemin-pngquant 压缩 png
          pngquant: {
            quality: [0.65, 0.9],
            speed: 4,
          },
          // 压缩 gif 的配置
          gifsicle: {
            interlaced: false,
          },
          // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式
          webp: {
            quality: 75,
          }
        }
      }
    ]
  }
]
```

#### 处理.vue 文件

`vue-loader` 是 `webpack` 的加载器模块，它使我们可以用 `.vue` 文件格式编写单文件组件。单文件组件文件有三个部分，即模板、脚本和样式。 `vue-loader` 模块允许 `webpack` 使用单独的加载器模块（例如 `sass 或 scss 加载器`）提取和处理每个部分。该设置使我们可以使用 `.vue` 文件无缝编写程序。

```js
{
  test: /\.vue$/,
  loader: 'vue-loader',
  options: vueLoaderConfig
}
```

### 开发一个 loader

需求：手写一个 `loader`，将 `'kobe'` 转换成 `'Black Mamba'`。当然大家可以根据自己的需求进行设计。这里只是讲解方法。

#### 1、编写 loader

在根目录下，新建目录 `kobe-loader` 作为我们编写 `loader` 的名称，执行 `npm init -y` 命令，新建一个模块化项目，然后新建 `index.js` 文件，相关源码如下：

```js
module.exports = function (content) {
  return content && content.replace(/kobe/gi, 'Black Mamba')
}
```

#### 2、注册模块

正常我们安装的 `loader` 是从 `npm` 下载安装，但是我们可以在 `kobe-loader` 目录底下使用 `npm link` 做到在不发布模块的情况下，将本地的一个正在开发的模块的源码链接到项目的 `node_modules` 目录下，让项目可以直接使用本地的 `npm` 模块。

```
npm link
```

然后在项目根目录执行以下命令，将注册到全局的本地 `npm` 模块链接到项目的 `node_modules` 下

```
$ npm link kobe-loader
```

注册成功后，我们可以在 `node_modules` 目录下能查找到对应的 `loader`。

#### 3、在 webpack 中配置 loader

在 `webpack.base.conf.js` 加上如下配置

```js
{
  test:/\.js/,
  loader: 'kobe-loader'
}
```

此时，我们在所有 js 文件下书写的 `'kobe'` 就全部替换成 `'Black Mamba'`了。

#### 4、配置参数

上面我们是写死的替换文案，假如我想通过配置项来改变，可以在 loader 中做以下调整

```js
// custom-loader/index.js
var utils = require('loader-utils')
module.exports = function (content) {
  const options = utils.getOptions(this)
  return content && content.replace(/kobe/gi, options.name)
}

// webpack.base.conf.js
{
  test:/\.js/,
  use: {
    loader: 'kobe-loader',
    options: {
      name: 'kobe',
    }
  }
}
```

## Plugin

专注处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。

### Plugin 的特点

- 是一个独立的模块
- 模块对外暴露一个 js 函数
- 函数的原型 `(prototype)` 上定义了一个注入 `compiler` 对象的 `apply`方法 `apply` 函数中需要有通过 `compiler` 对象挂载的 `webpack` 事件钩子，钩子的回调中能拿到当前编译的 `compilation` 对象，如果是异步编译插件的话可以拿到回调 `callback`
- 完成自定义子编译流程并处理 `complition` 对象的内部数据
- 如果异步编译插件的话，数据处理完成后执行 `callback` 回调。

### 常用 Plugin

- `HotModuleReplacementPlugin` 代码热替换。因为 `Hot-Module-Replacement` 的热更新是依赖于 `webpack-dev-server`，后者是在打包文件改变时更新打包文件或者 reload 刷新整个页面，`HRM` 是只更新修改的部分。
- `HtmlWebpackPlugin`, 生成 html 文件。将 webpack 中`entry`配置的相关入口 chunk 和 `extract-text-webpack-plugin`抽取的 css 样式 插入到该插件提供的`template`或者`templateContent`配置项指定的内容基础上生成一个 html 文件，具体插入方式是将样式`link`插入到`head`元素中，`script`插入到`head`或者`body`中。

- `ExtractTextPlugin`, 将 css 成生文件，而非内联 。该插件的主要是为了抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象。
- `NoErrorsPlugin`报错但不退出 webpack 进程
- `UglifyJsPlugin`，代码丑化，开发过程中不建议打开。 `uglifyJsPlugin` 用来对 js 文件进行压缩，从而减小 js 文件的大小，加速 load 速度。`uglifyJsPlugin` 会拖慢 webpack 的编译速度，所有建议在开发简单将其关闭，部署的时候再将其打开。多个 html 共用一个 js 文件(chunk)，可用 `CommonsChunkPlugin`

- `purifycss-webpack`  。打包编译时，可剔除页面和 js 中未被使用的 css，这样使用第三方的类库时，只加载被使用的类，大大减小 css 体积
- `optimize-css-assets-webpack-plugin`   压缩 css，优化 css 结构，利于网页加载和渲染
- `webpack-parallel-uglify-plugin`   可以并行运行 UglifyJS 插件，这可以有效减少构建时间

#### 开发一个插件

举个例子

```js
// 1、BasicPlugin.js 文件（独立模块）
// 2、模块对外暴露的 js 函数
class BasicPlugin {
  //在构造函数中获取用户为该插件传入的配置
  constructor(pluginOptions) {
    this.options = pluginOptions
  }
  //3、原型定义一个 apply 函数，并注入了 compiler 对象
  apply(compiler) {
    //4、挂载 webpack 事件钩子（这里挂载的是 emit 事件）
    compiler.plugin('emit', function (compilation, callback) {
      // ... 内部进行自定义的编译操作
      // 5、操作 compilation 对象的内部数据
      console.log(compilation)
      // 6、执行 callback 回调
      callback()
    })
  }
}
// 7、暴露 js 函数
module.exports = BasicPlugin
```
