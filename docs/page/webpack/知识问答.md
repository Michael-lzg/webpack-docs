# webpack 知识问答

## Webpack4.0 带来的优化
Webpack4.0 的构建速度远远快于 Webpack3.0，官方也说升级之后，升级版本之后，构建时间可以降低 60% - 98% 左右。

* v8 引擎带来的优化（for of 替代 forEach、Map 和 Set 替代 Object、includes 替代 indexOf）
* 默认使用更快的 md4 hash 算法
* webpack AST 可以直接从 loader 传递给 AST，减少解析时间
* 使用字符串方法替代正则表达式

## webpack 的执行流程
webpack从启动到结束会依次执行以下流程：

* 初始化：解析webpack配置参数，生产 Compiler 实例
* 注册插件：调用插件的apply方法，给插件传入compiler实例的引用，插件通过compiler调用Webpack提供的API，让插件可以监听后续的所有事件节点。
* 开始编译：读取入口文件
* 解析文件：使用loader将文件解析成抽象语法树 AST
* 生成依赖图谱：找出每个文件的依赖项（遍历）
* 输出：根据转换好的代码，生成 chunk
* 生成最后打包的文件

ps：由于 webpack 是根据依赖图动态加载所有的依赖项，所以，每个模块都可以明确表述自身的依赖，可以避免打包未使用的模块。

## ES6 转化为 ES5 的原理

- 解析：解析代码字符串，生成 AST；
- 转换：按一定的规则转换、修改 AST；
- 生成：将修改后的 AST 转换成普通代码。

## 热更新的原理分析
详情参考  https://zhuanlan.zhihu.com/p/30669007

<!-- - Webpack Compile: 将 JS 编译成 Bundle
- HMR Server: 将热更新的⽂件输出给 HMR Rumtime
- Bundle server: 提供⽂件在浏览器的访问 (比如 localhost:8080/Bundle.js)
- HMR Rumtime: 在开发阶段的打包阶段会被注⼊到浏览器端的 bundle.js 中，浏览器端的 bundle.js 会和浏览器建立一个连接，通常是一个 websocket,这样就可以更新文件的变化，当收到文件的一些变化消息时会自动更新文件
- bundle.js: 构建输出的⽂件 -->
#### 1. webpack 对文件系统进行 watch 打包到内存中
webpack-dev-middleware 调用 webpack 的 api 对文件系统 watch，当文件发生改变后，webpack 重新对文件进行编译打包，然后保存到内存中。  

webpack 将 bundle.js 文件打包到了内存中，不生成文件的原因就在于访问内存中的代码比访问文件系统中的文件更快，而且也减少了代码写入文件的开销。

#### 2. devServer 通知浏览器端文件发生改变
在启动 devServer 的时候，sockjs 在服务端和浏览器端建立了一个 webSocket 长连接，以便将 webpack 编译和打包的各个阶段状态告知浏览器，最关键的步骤还是 webpack-dev-server 调用 webpack api 监听 compile的 done 事件，当compile 完成后，webpack-dev-server通过 _sendStatus 方法将编译打包后的新模块 hash 值发送到浏览器端。

#### 3. webpack-dev-server/client 接收到服务端消息做出响应
webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会接收 websocket 消息的代码了。  

webpack-dev-server/client 当接收到 type 为 hash 消息后会将 hash 值暂存起来，当接收到 type 为 ok 的消息后对应用执行 reload 操作。在 reload 操作中，webpack-dev-server/client 会根据 hot 配置决定是刷新浏览器还是对代码进行热更新（HMR）。

#### 4.webpack 接收到最新 hash 值验证并请求模块代码
首先 webpack/hot/dev-server（以下简称 dev-server） 监听第三步 webpack-dev-server/client 发送的 webpackHotUpdate 消息，调用 webpack/lib/HotModuleReplacement.runtime（简称 HMR runtime）中的 check 方法，检测是否有新的更新。  

在 check 过程中会利用 webpack/lib/JsonpMainTemplate.runtime（简称 jsonp runtime）中的两个方法 hotDownloadManifest 和 hotDownloadUpdateChunk。  
hotDownloadManifest 是调用 AJAX 向服务端请求是否有更新的文件，如果有将发更新的文件列表返回浏览器端。该方法返回的是最新的 hash 值。  

hotDownloadUpdateChunk 是通过 jsonp 请求最新的模块代码，然后将代码返回给 HMR runtime，HMR runtime 会根据返回的新模块代码做进一步处理，可能是刷新页面，也可能是对模块进行热更新。该 方法返回的就是最新 hash 值对应的代码块。
最后将新的代码块返回给 HMR runtime，进行模块热更新。

#### 5. HotModuleReplacement.runtime 对模块进行热更新
这一步是整个模块热更新（HMR）的关键步骤，而且模块热更新都是发生在HMR runtime 中的 hotApply 方法中。  

模块热更新的错误处理，如果在热更新过程中出现错误，热更新将回退到刷新浏览器

#### 6. 构建输出的⽂件


## loader 的执行顺序

函数组合通常有两种方式，一种是从左到右(类似 unix 的 pipe)，另外一种是从右到左(compose)。webpack 选择的是 compose 方式，从右到左依次执行 loader，每个 loader 是一个函数。

webpack 里面的 compose 代码如下：

```js
const compose = (...fns) => {
  return fns.reduce(
    (prevFn, nextFn) => {
      return value => nextFn(prevFn(value))
    },
    value => value
  )
}
```

## loader 和 plugin 的区别

- loader，它是一个转换器，将 A 文件进行编译成 B 文件，比如：将 A.less 转换为 A.css，单纯的文件转换过程。webpack 自身只支持 js 和 json 这两种格式的文件，对于其他文件需要通过 loader 将其转换为 commonJS 规范的文件后，webpack 才能解析到

- plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。

## ⽂件哈希值

⽂件哈希值就是打包后输出的⽂件名的后缀

#### ⽂件哈希值如何⽣成

- Hash：和整个项⽬的构建相关，只要项⽬⽂件有修改，整个项⽬构建的 hash 值就会更改
- Chunkhash：和 webpack 打包的 chunk 有关，不同的 entry 会⽣成不同的 chunkhash 值
- Contenthash：根据⽂件内容来定义 hash ，⽂件内容不变，则 contenthash 不变

#### JS 的⽂件哈希设置

设置 output 的 filename，使⽤ [chunkhash]

```js
output: {
    filename: '[name][chunkhash:8].js',
    path: __dirname + '/dist'
}
```

注意: chunkhash 无法和热更新一起使用

#### CSS 的⽂件哈希设置

设置 MiniCssExtractPlugin 的 filename，使⽤ [contenthash]

```js
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
plugins: [
  new MiniCssExtractPlugin({
    filename: `[name][contenthash:8].css`
  })
]
```

如果想把 css 提取出来，那么 style-loader 就不能用了，因为两个是互斥的，所以我们可以这样写:

```js
module: {
  rules: [
      {
        test: /\.css$/,
        use: [
            - 'style-loader',
            + MiniCssExtractPlugin.loader
            'css-loader'
        ]
      },
      {
        test: /\.less$/,
        use: [
            - 'style-loader',
            + MiniCssExtractPlugin.loader
            'css-loader',
            'less-loader'
        ]
      },
  ]
},
```

#### 图片&字体文件哈希设置

代码如下：

```js
module: {
  rules: [
     {
       test: /\.(png|svg|jpg|gif)$/,
       use: [{
          loader: 'file-loader’,
          options: {
             name: 'img/[name][hash:8].[ext] '
          }
       }]
     }
  ]
}
```

## Dllplugin优化
在用 Webpack 打包的时候，对于一些不经常更新的第三方库，比如 react，lodash，vue 我们希望能和自己的代码分离开，Webpack 社区有两种方案：
* CommonsChunkPlugin
* DLLPlugin

对于 CommonsChunkPlugin，webpack 每次打包实际还是需要去处理这些第三方库，只是打包完之后，能把第三方库和我们自己的代码分开。而 DLLPlugin 则是能把第三方代码完全分离开，即每次只打包项目自身的代码。

#### 解决方法
1、在build下创建 webpack.dll.config.js
```js
const path = require('path')
const webpack = require('webpack')
module.exports = {
  entry: {
    vendor: [
      'vue-router',
      'vuex',
      'vue/dist/vue.common.js',
      'vue/dist/vue.js',
      'vue-loader/lib/component-normalizer.js',
      'vue',
      'axios',
      'echarts'
    ]
  },
  output: {
    path: path.resolve('./dist'),
    filename: '[name].dll.js',
    library: '[name]_library'
  },
  plugins: [
    new webpack.DllPlugin({
      path: path.resolve('./dist', '[name]-manifest.json'),
      name: '[name]_library'
    }),
    // 建议加上代码压缩插件，否则dll包会比较大。
    new webpack.optimize.UglifyJsPlugin({
      compress: {
        warnings: false
      }
    })
  ]
}
```

2、在 webpack.prod.conf.js 的 plugin 后面加入配置
```js
new webpack.DllReferencePlugin({
    manifest: require('../dist/vendor-manifest.json')
})
```

3、package.json文件中添加快捷命令(build:dll)
```js
  "scripts": {
    "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
    "start": "npm run dev",
    "lint": "eslint --ext .js,.vue src",
    "build": "node build/build.js",
    "build:dll": "webpack --config build/webpack.dll.conf.js"
  }
```
生产环境打包的时候先``npm run build:dll``命令会在打包目录下生成 ``vendor-manifest.json`` 文件与 vendor.dll.js 文件。然后``npm run build``生产其他文件。  

4、根目录下的入口 index.html 加入引用
```html
<script type="text/javascript" src="./vendor.dll.js"></script>
```

## 解决 vendor 文件过大的问题

1. CDN 方式引入资源
   把不常改变的库放到 index.html 中，通过 cdn 引入

```html
<script src="https://unpkg.com/vue@2.5.2/dist/vue.js"></script>
<script src="https://unpkg.com/vue-router@3.0.1/dist/vue-router.js"></script>
<script src="https://unpkg.com/mint-ui@2.2.13/lib/index.js"></script>
<script src="https://unpkg.com/element-ui@2.3.9/lib/index.js"></script>
<script src="https://unpkg.com/axios@0.18.0/dist/axios.min.js"></script>
```

配置 webpack 的 externals 属性

```js
externals:{
'vue':'Vue',
'element-ui':'ELEMENT',
'mint-ui':'MINT',
'axios':'axios',
'vue-router':'VueRouter',
}
```

2. 路由懒加载

```js
const router = [
  {
    path: '/index',
    component: resolve => require.ensure([], () => resolve(require('@/components/index')))
  },
  {
    path: '/about',
    component: resolve => require.ensure([], () => resolve(require('@/components/about')))
  }
]
```

## source map 生产环境怎么用
source map 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。
map文件只要不打开开发者工具，浏览器是不会加载的。线上环境一般有三种处理方案：

* hidden-source-map：借助第三方错误监控平台 Sentry 使用
* nosources-source-map：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高
* sourcemap：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)

注意：避免在生产中使用 inline- 和 eval-，因为它们会增加 bundle 体积大小，并降低整体性能。
