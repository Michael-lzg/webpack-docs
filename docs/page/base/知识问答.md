# webpack 知识问答


## webpack 的执行流程
webpack从启动到结束会依次执行以下流程：

* 初始化：解析webpack配置参数，生产 Compiler 实例
* 注册插件：调用插件的apply方法，给插件传入compiler实例的引用，插件通过compiler调用Webpack提供的API，让插件可以监听后续的所有事件节点。
* 开始编译：读取入口文件
* 解析文件：使用loader将文件解析成抽象语法树 AST
* 生成依赖图谱：找出每个文件的依赖项（遍历）
* 输出：根据转换好的代码，生成 chunk
* 生成最后打包的文件

ps：由于 webpack 是根据依赖图动态加载所有的依赖项，所以，每个模块都可以明确表述自身的依赖，可以避免打包未使用的模块。

## ES6 转化为 ES5 的原理

- 解析：解析代码字符串，生成 AST；
- 转换：按一定的规则转换、修改 AST；
- 生成：将修改后的 AST 转换成普通代码。

## 热更新的原理分析
详情参考  https://zhuanlan.zhihu.com/p/30669007

<!-- - Webpack Compile: 将 JS 编译成 Bundle
- HMR Server: 将热更新的⽂件输出给 HMR Rumtime
- Bundle server: 提供⽂件在浏览器的访问 (比如 localhost:8080/Bundle.js)
- HMR Rumtime: 在开发阶段的打包阶段会被注⼊到浏览器端的 bundle.js 中，浏览器端的 bundle.js 会和浏览器建立一个连接，通常是一个 websocket,这样就可以更新文件的变化，当收到文件的一些变化消息时会自动更新文件
- bundle.js: 构建输出的⽂件 -->
#### 1. webpack 对文件系统进行 watch 打包到内存中
webpack-dev-middleware 调用 webpack 的 api 对文件系统 watch，当文件发生改变后，webpack 重新对文件进行编译打包，然后保存到内存中。  

webpack 将 bundle.js 文件打包到了内存中，不生成文件的原因就在于访问内存中的代码比访问文件系统中的文件更快，而且也减少了代码写入文件的开销。

#### 2. devServer 通知浏览器端文件发生改变
在启动 devServer 的时候，sockjs 在服务端和浏览器端建立了一个 webSocket 长连接，以便将 webpack 编译和打包的各个阶段状态告知浏览器，最关键的步骤还是 webpack-dev-server 调用 webpack api 监听 compile的 done 事件，当compile 完成后，webpack-dev-server通过 _sendStatus 方法将编译打包后的新模块 hash 值发送到浏览器端。

#### 3. webpack-dev-server/client 接收到服务端消息做出响应
webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会接收 websocket 消息的代码了。  

webpack-dev-server/client 当接收到 type 为 hash 消息后会将 hash 值暂存起来，当接收到 type 为 ok 的消息后对应用执行 reload 操作。在 reload 操作中，webpack-dev-server/client 会根据 hot 配置决定是刷新浏览器还是对代码进行热更新（HMR）。

#### 4.webpack 接收到最新 hash 值验证并请求模块代码
首先 webpack/hot/dev-server（以下简称 dev-server） 监听第三步 webpack-dev-server/client 发送的 webpackHotUpdate 消息，调用 webpack/lib/HotModuleReplacement.runtime（简称 HMR runtime）中的 check 方法，检测是否有新的更新。  

在 check 过程中会利用 webpack/lib/JsonpMainTemplate.runtime（简称 jsonp runtime）中的两个方法 hotDownloadManifest 和 hotDownloadUpdateChunk。  
hotDownloadManifest 是调用 AJAX 向服务端请求是否有更新的文件，如果有将发更新的文件列表返回浏览器端。该方法返回的是最新的 hash 值。  

hotDownloadUpdateChunk 是通过 jsonp 请求最新的模块代码，然后将代码返回给 HMR runtime，HMR runtime 会根据返回的新模块代码做进一步处理，可能是刷新页面，也可能是对模块进行热更新。该 方法返回的就是最新 hash 值对应的代码块。
最后将新的代码块返回给 HMR runtime，进行模块热更新。

#### 5. HotModuleReplacement.runtime 对模块进行热更新
这一步是整个模块热更新（HMR）的关键步骤，而且模块热更新都是发生在HMR runtime 中的 hotApply 方法中。  

模块热更新的错误处理，如果在热更新过程中出现错误，热更新将回退到刷新浏览器

#### 6. 构建输出的⽂件





## 解决 vendor 文件过大的问题

1. CDN 方式引入资源
   把不常改变的库放到 index.html 中，通过 cdn 引入

```html
<script src="https://unpkg.com/vue@2.5.2/dist/vue.js"></script>
<script src="https://unpkg.com/vue-router@3.0.1/dist/vue-router.js"></script>
<script src="https://unpkg.com/mint-ui@2.2.13/lib/index.js"></script>
<script src="https://unpkg.com/element-ui@2.3.9/lib/index.js"></script>
<script src="https://unpkg.com/axios@0.18.0/dist/axios.min.js"></script>
```

配置 webpack 的 externals 属性

```js
externals:{
'vue':'Vue',
'element-ui':'ELEMENT',
'mint-ui':'MINT',
'axios':'axios',
'vue-router':'VueRouter',
}
```

2. 路由懒加载

```js
const router = [
  {
    path: '/index',
    component: resolve => require.ensure([], () => resolve(require('@/components/index')))
  },
  {
    path: '/about',
    component: resolve => require.ensure([], () => resolve(require('@/components/about')))
  }
]
```

