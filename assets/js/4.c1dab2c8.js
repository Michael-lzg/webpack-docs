(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{57:function(a,e,t){a.exports=t.p+"assets/img/webpack.efcef2ba.png"},70:function(a,e,t){"use strict";t.r(e);var r=[function(){var a=this,e=a.$createElement,r=a._self._c||e;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"webpack-与-glup"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webpack-与-glup","aria-hidden":"true"}},[a._v("#")]),a._v(" webpack 与 glup")]),a._v(" "),r("h3",{attrs:{id:"glup"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#glup","aria-hidden":"true"}},[a._v("#")]),a._v(" glup")]),a._v(" "),r("p",[a._v("gulp 强调的是前端开发的工作流程，我们可以通过配置一系列的 task，定义 task 处理的事务（例如文件压缩合并、雪碧图、启动 server、版本控制等），然后定义执行顺序，来让 gulp 执行这些 task，从而构建项目的整个前端开发流程。")]),a._v(" "),r("h3",{attrs:{id:"webpack"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webpack","aria-hidden":"true"}},[a._v("#")]),a._v(" webpack")]),a._v(" "),r("p",[a._v("webpack 是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js 文件、css 文件等）都看成模块，通过 loader（加载器）和 plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。")]),a._v(" "),r("h3",{attrs:{id:"二者区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二者区别","aria-hidden":"true"}},[a._v("#")]),a._v(" 二者区别")]),a._v(" "),r("ol",[r("li",[a._v("虽然都是前端自动化构建工具，但看他们的定位就知道不是对等的。")])]),a._v(" "),r("ul",[r("li",[a._v("gulp严格上讲，模块化不是他强调的东西，他旨在规范前端开发流程。")]),a._v(" "),r("li",[a._v("webpack更是明显强调模块化开发，而那些文件压缩合并、预处理等功能，不过是他附带的功能。")])]),a._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[a._v("gulp 走的是流式处理路线，webpack 走的是模块处理路线")])]),a._v(" "),r("img",{attrs:{src:t(57)}}),a._v(" "),r("h3",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("gulp应该与grunt比较，而webpack应该与browserify（网上太多资料就这么说，这么说是没有错，不过单单这样一句话并不能让人清晰明了）。")])]),a._v(" "),r("li",[r("p",[a._v("gulp是基于流的自动化构建工具，但不包括模块化的功能，如果要用到的话，就需要引入外部文件，比如require.js等；而webpack是自动化模块打包工具，本身就具有模块化，并且也具有压缩合并的功能。二者侧重点不同，我认为相互结合使用会提高代码质量和代码的优化。")])]),a._v(" "),r("li",[r("p",[a._v("gulp与webpack上是互补的，还是可替换的，取决于你项目的需求。如果只是个vue或react的单页应用，webpack也就够用；如果webpack某些功能使用起来麻烦甚至没有（雪碧图就没有），那就可以结合gulp一起用。")])])]),a._v(" "),r("h3",{attrs:{id:"webpack-对比-requirejs"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webpack-对比-requirejs","aria-hidden":"true"}},[a._v("#")]),a._v(" webpack 对比 requirejs")]),a._v(" "),r("ol",[r("li",[a._v("webpack 在管理模块的时候不需要再封装一层像 requireJS 如下的东西")])]),a._v(" "),r("p",[a._v("define(['jquery'], function(jquery){})")]),a._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[a._v("它实现了前端代码模块化，提高了代码的复用性，从而提供公共模块的缓存功能。")])]),a._v(" "),r("ul",[r("li",[a._v("webpack 通过打包，不同页面单独加载自己的模块的 javascript 和 common javascript，而 requireJS 将所有的 javascript 文件打包成一个文件，使得一个站点中多个页面之间公用的 JS 模块无法缓存。")]),a._v(" "),r("li",[a._v("webpack 引入了切分点（split point）与代码块（Chunk），切分点定义了所有依赖的模块，合起来就是一个代码块，从而实现一个页面引用一个代码块。")])])])}],s=t(0),i=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},r,!1,null,null,null);e.default=i.exports}}]);